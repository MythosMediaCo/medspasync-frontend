# AUTONOMOUS PERFORMANCE OPTIMIZATION
# Systematic performance analysis and optimization

## PERFORMANCE OPTIMIZATION WORKFLOW

### PHASE 1: BASELINE ESTABLISHMENT
1. **Performance Benchmarking**
   - Generate comprehensive performance benchmarks
   - Establish Core Web Vitals baselines
   - Create performance budgets for each metric
   - Document current performance characteristics

2. **Critical Path Identification**
   - Identify critical user journeys and bottlenecks
   - Map performance impact of each component
   - Analyze resource loading patterns
   - Establish performance monitoring points

3. **Performance Testing Suite**
   - Create automated performance testing suite
   - Implement continuous performance monitoring
   - Set up performance regression detection
   - Configure performance alerting

### PHASE 2: ANALYSIS & PROFILING
1. **Detailed Profiling**
   - Execute detailed profiling across all system layers
   - Analyze JavaScript execution performance
   - Evaluate CSS rendering and layout performance
   - Assess network latency and caching opportunities

2. **Resource Utilization Analysis**
   - Analyze bundle size and composition
   - Evaluate image optimization opportunities
   - Assess third-party script impact
   - Monitor memory usage patterns

3. **User Experience Metrics**
   - Collect Real User Monitoring (RUM) data
   - Analyze Core Web Vitals in production
   - Monitor user interaction patterns
   - Identify performance pain points

### PHASE 3: OPTIMIZATION IMPLEMENTATION
1. **Code Optimization**
   - Apply proven optimization patterns systematically
   - Implement code splitting and lazy loading
   - Optimize React rendering performance
   - Apply bundle optimization techniques

2. **Resource Optimization**
   - Implement caching strategies at appropriate layers
   - Optimize image loading and formats
   - Minimize third-party script impact
   - Implement critical CSS inlining

3. **Infrastructure Optimization**
   - Optimize CDN configuration
   - Implement service worker caching
   - Configure HTTP/2 optimization
   - Optimize server response times

### PHASE 4: VALIDATION & MONITORING
1. **Performance Validation**
   - Measure optimization impact with before/after metrics
   - Validate Core Web Vitals improvements
   - Test performance across different devices and networks
   - Verify optimization doesn't introduce regressions

2. **Continuous Monitoring**
   - Implement continuous performance monitoring
   - Create alerting for performance regression detection
   - Monitor performance trends over time
   - Document optimization techniques for future reference

## CORE WEB VITALS OPTIMIZATION

### Largest Contentful Paint (LCP) < 2.5s
```typescript
// LCP optimization strategies
- Optimize critical rendering path
- Implement resource hints (preload, prefetch)
- Optimize server response times
- Use efficient image formats (WebP, AVIF)
- Implement critical CSS inlining
```

### First Input Delay (FID) < 100ms
```typescript
// FID optimization strategies
- Minimize JavaScript execution time
- Implement code splitting and lazy loading
- Optimize event handler performance
- Use web workers for heavy computations
- Implement efficient state management
```

### Cumulative Layout Shift (CLS) < 0.1
```typescript
// CLS optimization strategies
- Reserve space for dynamic content
- Optimize image and video dimensions
- Implement skeleton loading states
- Avoid inserting content above existing content
- Use CSS containment for layout isolation
```

### First Contentful Paint (FCP) < 1.8s
```typescript
// FCP optimization strategies
- Optimize critical rendering path
- Minimize render-blocking resources
- Implement efficient CSS delivery
- Optimize server response times
- Use resource hints for critical resources
```

## BUNDLE OPTIMIZATION

### Code Splitting Strategy
```javascript
// Dynamic imports for code splitting
const LazyComponent = lazy(() => import('./LazyComponent'))

// Route-based code splitting
const HomePage = lazy(() => import('./pages/HomePage'))
const AboutPage = lazy(() => import('./pages/AboutPage'))
const ContactPage = lazy(() => import('./pages/ContactPage'))
```

### Tree Shaking Configuration
```javascript
// Vite configuration for tree shaking
export default defineConfig({
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['react', 'react-dom'],
          utils: ['lodash-es', 'date-fns'],
          ui: ['@headlessui/react', '@heroicons/react']
        }
      }
    }
  }
})
```

### Bundle Analysis
```bash
# Bundle analysis commands
npm run build:analyze    # Generate bundle analysis report
npm run lighthouse       # Performance analysis
npm run test:performance # Performance testing
```

## IMAGE OPTIMIZATION

### Image Optimization Strategy
```typescript
// Image optimization implementation
- Use WebP and AVIF formats with fallbacks
- Implement responsive images with srcset
- Apply lazy loading for below-the-fold images
- Optimize image dimensions and compression
- Use appropriate image formats for content type
```

### Image Loading Patterns
```jsx
// Optimized image component
import { useState } from 'react'

const OptimizedImage = ({ src, alt, ...props }) => {
  const [isLoaded, setIsLoaded] = useState(false)
  
  return (
    <div className="image-container">
      {!isLoaded && <div className="skeleton" />}
      <img
        src={src}
        alt={alt}
        loading="lazy"
        onLoad={() => setIsLoaded(true)}
        className={isLoaded ? 'loaded' : 'loading'}
        {...props}
      />
    </div>
  )
}
```

## CACHING STRATEGIES

### Service Worker Caching
```javascript
// Service worker caching strategy
const CACHE_NAME = 'medspasync-v1'
const STATIC_CACHE = 'static-v1'
const DYNAMIC_CACHE = 'dynamic-v1'

// Cache static assets
workbox.routing.registerRoute(
  ({ request }) => request.destination === 'style' || request.destination === 'script',
  new workbox.strategies.StaleWhileRevalidate({
    cacheName: STATIC_CACHE
  })
)

// Cache API responses
workbox.routing.registerRoute(
  ({ url }) => url.pathname.startsWith('/api/'),
  new workbox.strategies.NetworkFirst({
    cacheName: DYNAMIC_CACHE
  })
)
```

### HTTP Caching Headers
```javascript
// Cache control headers
const cacheHeaders = {
  'Cache-Control': 'public, max-age=31536000, immutable',
  'ETag': generateETag(content),
  'Last-Modified': new Date().toUTCString()
}
```

## REACT PERFORMANCE OPTIMIZATION

### Component Optimization
```jsx
// Optimized React component
import { memo, useMemo, useCallback } from 'react'

const OptimizedComponent = memo(({ data, onAction }) => {
  // Memoize expensive calculations
  const processedData = useMemo(() => {
    return data.map(item => ({
      ...item,
      processed: expensiveCalculation(item)
    }))
  }, [data])

  // Memoize event handlers
  const handleClick = useCallback((id) => {
    onAction(id)
  }, [onAction])

  return (
    <div>
      {processedData.map(item => (
        <div key={item.id} onClick={() => handleClick(item.id)}>
          {item.name}
        </div>
      ))}
    </div>
  )
})
```

### State Management Optimization
```jsx
// Optimized state management
import { useReducer, useCallback } from 'react'

const initialState = {
  data: [],
  loading: false,
  error: null
}

const reducer = (state, action) => {
  switch (action.type) {
    case 'SET_LOADING':
      return { ...state, loading: action.payload }
    case 'SET_DATA':
      return { ...state, data: action.payload, loading: false }
    case 'SET_ERROR':
      return { ...state, error: action.payload, loading: false }
    default:
      return state
  }
}

const useOptimizedState = () => {
  const [state, dispatch] = useReducer(reducer, initialState)
  
  const setLoading = useCallback((loading) => {
    dispatch({ type: 'SET_LOADING', payload: loading })
  }, [])
  
  const setData = useCallback((data) => {
    dispatch({ type: 'SET_DATA', payload: data })
  }, [])
  
  return { state, setLoading, setData }
}
```

## PERFORMANCE MONITORING

### Real User Monitoring (RUM)
```javascript
// Performance monitoring implementation
const performanceObserver = new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    // Send performance data to analytics
    analytics.track('performance', {
      metric: entry.name,
      value: entry.value,
      timestamp: Date.now()
    })
  }
})

performanceObserver.observe({ entryTypes: ['navigation', 'resource', 'paint'] })
```

### Performance Budgets
```javascript
// Performance budget configuration
const performanceBudgets = {
  lcp: 2500,    // 2.5 seconds
  fid: 100,     // 100 milliseconds
  cls: 0.1,     // 0.1
  fcp: 1800,    // 1.8 seconds
  bundleSize: 500 * 1024, // 500KB
  imageSize: 200 * 1024   // 200KB
}
```

## AUTOMATED PERFORMANCE TESTING

### Performance Test Implementation
```typescript
// Performance test example
import { test, expect } from '@playwright/test'

test('should meet performance budgets', async ({ page }) => {
  // Navigate to page
  await page.goto('/')
  
  // Wait for page to load
  await page.waitForLoadState('networkidle')
  
  // Measure Core Web Vitals
  const metrics = await page.evaluate(() => {
    return new Promise((resolve) => {
      new PerformanceObserver((list) => {
        const entries = list.getEntries()
        const metrics = {}
        
        entries.forEach((entry) => {
          if (entry.entryType === 'navigation') {
            metrics.fcp = entry.firstContentfulPaint
            metrics.lcp = entry.largestContentfulPaint
          }
        })
        
        resolve(metrics)
      }).observe({ entryTypes: ['navigation'] })
    })
  })
  
  // Assert performance budgets
  expect(metrics.fcp).toBeLessThan(1800)
  expect(metrics.lcp).toBeLessThan(2500)
})
```

## PERFORMANCE OPTIMIZATION CHECKLIST

### Loading Performance
- [ ] Implement code splitting and lazy loading
- [ ] Optimize critical rendering path
- [ ] Use resource hints (preload, prefetch)
- [ ] Optimize image loading and formats
- [ ] Implement service worker caching

### Runtime Performance
- [ ] Optimize React rendering with memo, useMemo, useCallback
- [ ] Implement efficient state management
- [ ] Use web workers for heavy computations
- [ ] Optimize event handler performance
- [ ] Implement virtual scrolling for large lists

### Network Performance
- [ ] Optimize bundle size and composition
- [ ] Implement efficient caching strategies
- [ ] Minimize third-party script impact
- [ ] Optimize API response times
- [ ] Use CDN for static assets

### User Experience
- [ ] Implement skeleton loading states
- [ ] Optimize layout stability (CLS)
- [ ] Provide immediate feedback for user interactions
- [ ] Implement progressive enhancement
- [ ] Ensure accessibility during loading states 